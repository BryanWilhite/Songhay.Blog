<html>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="Generator" content="PowerTools for Open XML" />
        <title>My Page Title Tuesday, November 22, 2016 5:33:00 AM</title>
    </head>

    <body>
        <h2 id="flippant-remarks-about-karma-jasmine-in-angular">flippant remarks about Karma-Jasmine in Angular</h2>
        <p>The details below try to explain these fundamentals:</p>
        <ul>
            <li>use <code>NO_ERRORS_SCHEMA</code></li>
            <li>initialize properties used in component-binding HTML to prevent <code>[object ErrorEvent] thrown</code></li>
            <li>call <code>overrideComponent</code> to null or mock services for the component spec</li>
            <li>consider using inline mocks with <code>useValue</code> for providers</li>
            <li>consider using the “Elvis operator” in component-binding HTML</li>
            <li>be ready to use <code>HttpClientTestingModule</code>, <code>HttpTestingController</code> and/or <code>RouterTestingModule</code></li>
            <li>comment out <code>fixture.detectChanges()</code> to narrow down troubleshooting binding or initialization issues</li>
        </ul>
        <p>One, <a href="https://github.com/BryanWilhite/nodejs/tree/master/karma-and-jasmine-minimal">small introduction to Karma-Jasmine</a> outside of Angular reminds us <a href="https://karma-runner.github.io/latest/index.html">Karma</a> is the “test runner” (from the Angular team) and <a href="https://jasmine.github.io/">Jasmine</a> is a behavior driven development framework. <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Behavior Driven Development</a> is beyond the scope of these remarks apart from the consideration that we might make when use the word <em>specification</em> instead of <em>test</em>.</p>
        <h3 id="a-jasmine-.spec.ts-file-is-generated-by-the-angular-cli-by-default">a Jasmine <code>*.spec.ts</code> file is generated by the Angular CLI by default</h3>
        <p>Unless the <code>--spec=false</code> option is explicitly used, <code>ng generate component</code> [<a href="https://angular.io/cli/generate#component">docs</a>] will auto-generate a Jasmine spec file like this:</p>
        <pre class="typescript"><code>
import { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;

import { MyComponent } from &#39;./my.component&#39;;

describe(&#39;MyComponent&#39;, () =&gt; {
    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        declarations: [ MyComponent ]
    })
    .compileComponents();
    }));

    beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
    });

    it(&#39;should create&#39;, () =&gt; {
    expect(component).toBeTruthy();
    });
});</code></pre>
        <p>One way to easily be confused by the Karma-Jasmine combo is not really, really understanding that <code>async</code>, <code>ComponentFixture</code> and <code>TestBed</code> do <em>not</em> come from Jasmine—we must depend on the Angular team to <a href="https://angular.io/guide/testing">tell us</a> about these things. One of these things is the use of <code>async</code> with <code>beforeEach</code>. A <a href="https://stackoverflow.com/a/40127164/22944">StackOverflow.com answer</a> asserts that <code>async</code> (from the Angular team) replaces the use of <code>done()</code> which is native to Jasmine [<a href="https://jasmine.github.io/tutorials/async">docs</a>]. <code>ComponentFixture</code> and <code>TestBed</code> are covered reasonably well by the Angular team [<a href="https://angular.io/guide/testing#component-test-basics">docs</a>].</p>
        <h3 id="using-no_errors_schema">using <code>NO_ERRORS_SCHEMA</code></h3>
        <p>The auto-generated test above might be for a component with an HTML file like this:</p>
        <div class="sourceCode" id="cb2">
            <pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;css-class&quot;</span><span class="kw">&gt;</span></a>
        <a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="kw">&lt;app-my-child</span><span class="ot"> [prop1]=</span><span class="st">&quot;foo.bar&quot;</span><span class="ot"> [prop2]=</span><span class="st">&quot;fuBar.prop3&quot;</span><span class="kw">&gt;&lt;/app-my-child&gt;</span></a>
        <a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">&lt;/div&gt;</span></a></code></pre>
        </div>
        <p>By default, the test will likely throw a very verbose error like this:</p>
        <pre class="console"><code>Failed: Template parse errors:
        &#39;app-my-child&#39; is not a known element:
        1. If &#39;app-my-child&#39; is an Angular component, then verify that it is part of this module.
        …</code></pre>
        <p>We need to tell our <code>TestBed</code> to ignore “custom” elements like <code>app-my-child</code>:</p>
        <pre class="typescript"><code>
import { NO_ERRORS_SCHEMA } from &#39;@angular/core&#39;;

import { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;

import { MyComponent } from &#39;./my.component&#39;;

describe(MyComponent.name, () =&gt; {
    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        declarations: [ MyComponent ],
        schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
    }));

    beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
    });

    it(&#39;should create&#39;, () =&gt; {
    expect(component).toBeTruthy();
    });
});</code></pre>
        <p>For more detail on <code>NO_ERRORS_SCHEMA</code>, see the <a href="https://angular.io/guide/testing#no_errors_schema">docs</a>. Also note that we can cut down on the use of magic strings by using <code>MyComponent.name</code> which is convenience from the Angular team.</p>
        <h3 id="the-mysterious-object-errorevent-thrown-error">the mysterious <code>[object ErrorEvent] thrown</code> error</h3>
        <p>The <code>NO_ERRORS_SCHEMA</code> remedy might be followed by another, more mysterious Jasmine error:</p>
        <pre class="console"><code>[object ErrorEvent] thrown</code></pre>
        <p>What is happening in our HTML example above is the null value of <code>foo</code> in the binding <code>foo.bar</code> and the null value of <code>fuBar</code> in the binding <code>fuBar.prop3</code>. The typescript of a component backing these bindings might look like this:</p>
        <pre class="typescript"><code>
import { Component, OnInit } from &#39;@angular/core&#39;;
import { FooService } from &#39;../../services/foo.service&#39;;

@Component({
    selector: &#39;app-my-widget&#39;,
    templateUrl: &#39;./my.component.html&#39;,
    styleUrls: [&#39;./my.component.css&#39;]
})
export class ContextPanelComponent implements OnInit {
    @Input
    fuBar: {};

    constructor(public foo: FooService) { }

    ngOnInit() {
    foo.loadBar();
    }
}</code></pre>
        <p>We see that <code>fuBar</code> is an <code>@Input</code> property and <code>foo</code> is injected as a service. To address these members of the component, we update our Jasmine spec:</p>
        <pre class="typescript"><code>
import { NO_ERRORS_SCHEMA } from &#39;@angular/core&#39;;

import { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;

import { FooService } from &#39;../../services/foo.service&#39;;
import { MyComponent } from &#39;./my.component&#39;;

describe(MyComponent.name, () =&gt; {
    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        declarations: [ MyComponent ],
        schemas: [ NO_ERRORS_SCHEMA ]
    })
    .overrideComponent(MyComponent, {
        set: { providers: [ { provide: FooService, useValue: null } ] }
    })
    .compileComponents();
    }));

    beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;

    component.fuBar = { prop3: null };

    fixture.detectChanges();
    });

    it(&#39;should create&#39;, () =&gt; {
    expect(component).toBeTruthy();
    });
});</code></pre>
        <p>This updated spec should still throw the same cryptic error, <code>[object ErrorEvent] thrown</code>, because, while we <em>did</em> address <code>fuBar</code>, we did <em>not</em> provide a value for <code>FooService</code>. It is often useful to provide a null value for a service to show that the service might not be necessary and should be removed from the component. Let’s flippantly provide a value for <code>FooService</code>:</p>
        <pre class="typescript"><code>
import { NO_ERRORS_SCHEMA } from &#39;@angular/core&#39;;

import { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;

import { FooService } from &#39;../../services/foo.service&#39;;
import { MyComponent } from &#39;./my.component&#39;;

describe(MyComponent.name, () =&gt; {
    const fooService = { bar: null };

    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        declarations: [ MyComponent ],
        schemas: [ NO_ERRORS_SCHEMA ]
    })
    .overrideComponent(MyComponent, {
        set: { providers: [ { provide: FooService, useValue: fooService } ] }
    })
    .compileComponents();
    }));

    beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;

    component.fuBar = { prop3: null };

    fixture.detectChanges();
    });

    it(&#39;should create&#39;, () =&gt; {
    expect(component).toBeTruthy();
    });
});</code></pre>
        <p>The spec should now be valid. Now we can actually specify an interesting behavior (write an actual test). Let’s test whether <code>foo.loadBar()</code> was called by <em>spying</em> on it. We can replace <code>fooService</code> with the value of <code>createSpyObj()</code> [<a href="https://jasmine.github.io/api/2.8/jasmine.html#.createSpyObj">docs</a>]:</p>
        <pre class="typescript"><code>
import { NO_ERRORS_SCHEMA } from &#39;@angular/core&#39;;

import { async, ComponentFixture, TestBed } from &#39;@angular/core/testing&#39;;

import { FooService } from &#39;../../services/foo.service&#39;;
import { MyComponent } from &#39;./my.component&#39;;

describe(MyComponent.name, () =&gt; {
    const loadBarMethodName = &#39;loadBar&#39;;
    const fooService = jasmine.createSpyObj(FooService.Name, [loadBarMethodName]);
    fooService.bar = null;

    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        declarations: [ MyComponent ],
        schemas: [ NO_ERRORS_SCHEMA ]
    })
    .overrideComponent(MyComponent, {
        set: { providers: [ { provide: FooService, useValue: fooService } ] }
    })
    .compileComponents();
    }));

    beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;

    fooService[loadBarMethodName].calls.reset();
    component.fuBar = { prop3: null };

    fixture.detectChanges();
    });

    it(&#39;should create&#39;, () =&gt; {
    expect(component).toBeTruthy();
    });

    it(`should call ${loadBarMethodName}`, () =&gt; {
    expect(fooService[loadBarMethodName].calls.count()).toBe(1, &#39;The expected number of service calls is not here.&#39;);
    });

});</code></pre>
        <p>In typescript, <code>fooService</code> will be of type <code>any</code>. So, when we see the <code>calls</code> object (or “namespace”) hanging off it, we might need to go to <a href="https://jasmine.github.io/api/2.8/Spy_calls.html">the Jasmine documentation</a> to see what is going on.</p>
        <h3 id="use-of-the-elvis-operator-in-component-binding-html">use of the “Elvis operator” in component-binding HTML</h3>
        <p>Had our HTML been like this:</p>
        <div class="sourceCode" id="cb10">
            <pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;css-class&quot;</span><span class="kw">&gt;</span></a>
        <a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="kw">&lt;app-my-child</span><span class="ot"> [prop1]=</span><span class="st">&quot;foo?.bar&quot;</span><span class="ot"> [prop2]=</span><span class="st">&quot;fuBar?.prop3&quot;</span><span class="kw">&gt;&lt;/app-my-child&gt;</span></a>
        <a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">&lt;/div&gt;</span></a></code></pre>
        </div>
        <p>We could have avoided writing these lines of spec code:</p>
        <pre class="typescript"><code>
fooService.bar = null;
…
component.fuBar = { prop3: null };</code></pre>
        <p>The use the Elvis operator has some issues with async in bindings, see “<a href="https://hackernoon.com/the-angry-angular-asyncpipe-the-evil-elvis-operator-89293e37e04d">The Angry Angular AsyncPipe &amp; The Evil Elvis Operator</a>” by Vitaliy Isikov.</p>
        <h3 id="the-right-way-to-initialize-input-values">the ‘right’ way to initialize <code>@Input</code> values</h3>
        <p>In my example above, you see me explicitly setting the value of <code>fuBar</code>. To test whether <code>@Input</code> is working (which is kind of like testing something that belongs to the Angular team) we can set up a mock component to host <code>MyComponent</code>. This is detailed in “<span class="citation" data-cites="Input">[Testing Angular components with @Input()]</span>(https://medium.com/<span class="citation" data-cites="AikoPath/testing-angular-components-with-input-3bd6c07cfaf6">@AikoPath/testing-angular-components-with-input-3bd6c07cfaf6</span>)” by Aiko Klostermann of Thoughtworks.</p>
        <h3 id="using-formal-mocks">using formal mocks</h3>
        <p>I am very, very certain that Angular team does not recommend constructing a mock inline as we have seen above:</p>
        <pre class="typescript"><code>const loadBarMethodName = &#39;loadBar&#39;;
        const fooService = jasmine.createSpyObj(FooService.Name, [loadBarMethodName]);
        fooService.bar = null;</code></pre>
        <p>I find this helpful when I am <em>not</em> repeating myself in multiple <code>*.spec.ts</code> files and it is less intimidating to first-time Jasmine writers.</p>
        <h3 id="commenting-out-fixture.detectchanges">commenting out <code>fixture.detectChanges()</code></h3>
        <p>Commenting out <code>fixture.detectChanges()</code> in specs might prevent the spec from throwing errors. This is a surefire way to consider that any failures with this line enabled are due to binding issues.</p>
        <h3 id="the-auto-generated-tests-for-services-look-different">the auto-generated tests for services look different</h3>
        <p>When a test for a service is generated (with <code>ng generate service</code> [<a href="https://angular.io/cli/generate#service">docs</a>]) the main difference is the use of <code>inject</code> (also from the Angular team):</p>
        <pre class="typescript"><code>it(&#39;should be created&#39;, inject([MyService], (service: MyService) =&gt; {
          expect(service).toBeTruthy();
        }));</code></pre>
        <p>The other difference is that you cannot use <code>overrideComponent</code> for a service spec; set <code>providers</code> in <code>configureTestingModule</code>:</p>
        <pre class="typescript"><code>
beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        imports: [HttpClientTestingModule, RouterTestingModule],
        providers: [ { provide: FooService, useValue: null } ]
    });
}));</code></pre>
        <h3 id="the-nullinjectorerror-no-provider-for-httpclient-error">the <code>NullInjectorError: No provider for HttpClient!</code> error</h3>
        <p>When the <code>NullInjectorError: No provider for HttpClient!</code> error is thrown, the knee-jerk response is to add <code>imports: [HttpClientModule]</code> to the <code>TestBed</code>. The better response is to import <code>HttpClientTestingModule</code> (with <code>HttpTestingController</code>) instead. This is detailed in “<a href="https://medium.com/netscape/testing-with-the-angular-httpclient-api-648203820712">Testing with the Angular HttpClient API</a>” by Ciro Nunes.</p>
        <p>There is a similar Karma-Jasmine error that should lead us to importing <code>RouterTestingModule</code> as described in “<a href="https://medium.com/burak-tasci/using-jasmine-framework-to-test-angular-router-b568a232efed">Using Jasmine framework to test Angular Router</a>” by Burak Tasci.</p>
        <p>@<a href="http://twitter.com/BryanWilhite">BryanWilhite</a></p>
    </body>
</html>